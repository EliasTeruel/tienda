Frontend (React) â†’ Firebase Hosting + Firebase Auth
                   â†“
Backend (FastAPI - Python) â†’ Railway o Render
                             â†“
PostgreSQL (Neon.tech)
                             â†“
ImÃ¡genes (Cloudinary)

------------------------------------------------------------------
Para clonar el repositorio y que funcione en otra computadora, sigue estos pasos:

Clonar el repositorio: Abre la terminal y ejecuta:

git clone <URL_DEL_REPOSITORIO>
cd <nombre_del_repositorio>

Crear y activar un entorno virtual (recomendado):

python -m venv venv
venv\Scripts\activate

Instalar las dependencias: Si tienes un archivo requirements.txt, ejecuta:

pip install -r requirements.txt

Configurar variables de entorno:

Renombra .env.example a .env. (NO HACE FALTA ESTA PARTE)
Completa los valores necesarios (Cloudinary, DATABASE_URL, etc.).
Inicializar la base de datos: Ejecuta el script de inicializaciÃ³n:

python tienda/fastapi_tienda/app/scripts/init_db.py (NO HACE FALTA ESTA PARTE)

Ejecutar el servidor FastAPI:

uvicorn app.main:app --reload


Notas:

Instala Python y pip si no los tienes.
Instala uvicorn si no estÃ¡: pip install uvicorn.
Instala las librerÃ­as necesarias (FastAPI, SQLAlchemy, cloudinary, etc.).

------------------------------------------------------------------
1. Configurar tu Backend (FastAPI)

python -m venv env
source env/bin/activate  # Windows: .\env\Scripts\activate
pip install fastapi uvicorn python-dotenv psycopg2-binary


nueva estructura:
fastapi_tienda/
â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py               # Punto de entrada de la app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ config.py             # ConfiguraciÃ³n (Cloudinary, CORS, variables de entorno)
â”‚   â”œâ”€â”€ crud.py             
â”‚   â”œâ”€â”€ models.py             # Modelos Pydantic
â”‚   â”œâ”€â”€ database.py           # SimulaciÃ³n o conexiÃ³n a base de datos
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ productos.py      # Rutas de productos
â”‚   â”‚   â”œâ”€â”€ imagenes.py       # Rutas de subida de imÃ¡genes
â”‚   â””â”€â”€ services/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ cloudinary_service.py  # LÃ³gica de subida de imÃ¡genes
â”‚
â”œâ”€â”€ .env                      # Variables de entorno
â”œâ”€â”€ requirements.txt          # Dependencias del proyecto
â””â”€â”€ README.md


Guardar dependencias:
pip freeze > requirements.txt

------------------------------------------------------------------
 2. Subir Backend a Railway
Railway:
Crear cuenta: https://railway.app

Nuevo proyecto â†’ â€œDeploy from GitHubâ€ o â€œStart from scratchâ€

SubÃ­s el proyecto a GitHub

Railway detecta main.py y requirements.txt automÃ¡ticamente

Setea variable PORT = 8000 en Railway

ğŸš€ El backend quedarÃ¡ disponible en https://tuapp.up.railway.app

------------------------------------------------------------------

3. Crear base de datos en Neon
Ir a: https://neon.tech

Crear proyecto â†’ copiar cadena de conexiÃ³n PostgreSQL

En tu backend, guardar en .env:
DATABASE_URL=postgresql://usuario:password@host.db.neon.tech:5432/dbname


se crea tabla con el script init_db.py que para que funcione se debe instalar:

pip install sqlalchemy psycopg2-binary
python scripts/init_db.py

Esto:

Crea la tabla productos si no existe.

Inserta dos productos de ejemplo.



------------------------------------------------------------------

------------------------------------------------------------------
4. Configurar Cloudinary (para imÃ¡genes)
Ir a: https://cloudinary.com

Crear cuenta y copiar datos del dashboard:

CLOUD_NAME

API_KEY

API_SECRET

Guardar en .env del backend
CLOUDINARY_CLOUD_NAME=...
CLOUDINARY_API_KEY=...
CLOUDINARY_API_SECRET=...


------------------------------------------------------------------
UsÃ¡s cloudinary SDK en Python:

pip install cloudinary


------------------------------------------------------------------

Frontend en React:
npx create-react-app tienda-front
cd tienda-front
npm install firebase axios react-router-dom
------------------------------------------------------------------
Configurar Firebase:
Ir a: https://console.firebase.google.com

Crear proyecto â†’ activar Authentication â†’ elegir â€œEmail/Passwordâ€ o â€œGoogleâ€

Activar Hosting â†’ te darÃ¡ un dominio mi-tienda.web.app

npm install -g firebase-tools

Agregar Firebase al React:
// src/firebase.js
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";

const firebaseConfig = {
  apiKey: "...",
  authDomain: "...",
  projectId: "...",
  appId: "...",
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);


------------------------------------------------------------------
6. Conectar frontend con backend
UsÃ¡s axios desde React para llamar a https://tu-backend.up.railway.app/productos

ManejÃ¡s tokens de login desde Firebase para validar en tu API si querÃ©s proteger endpoints


------------------------------------------------------------------
7. Subir el frontend a Firebase Hosting

npm install -g firebase-tools
firebase login
firebase init hosting
# SeleccionÃ¡s el proyecto y como carpeta `build/`
npm run build
firebase deploy


------------------------------------------------------------------
se agrega 
  "proxy": "http://localhost:8000"

en package.json del front


------------------------------------------------------------------
comandos:

npm start -> compila de manera local solo la parte de react, no se usaria mas
firebase serve ->compila de manera local solo la parte de react pero usando firebase
npm run buil -> compila todo lo aplicado de manera local para deployarlo en prod
firebase deploy -> sube los cambios a produccion

despues de hacer cambios y mostrarlo en local hay que hacer:
npm run buil
firebase serve

despues de hacer cambios y mostrarlo en PROduccion hay que hacer:
npm run buil
firebase deploy

------------------------------------------------------------------
Explicacion del funcionamiento de los archivos para react y firebase:

ğŸ”¹ 1. Nivel inicial: Carpeta src/

AcÃ¡ estÃ¡ tu cÃ³digo fuente, el que vos programÃ¡s. Ejemplo tÃ­pico:
src/
 â”œâ”€â”€ index.js        ğŸ‘ˆ Punto de entrada principal
 â”œâ”€â”€ App.js          ğŸ‘ˆ Componente raÃ­z de tu app
 â”œâ”€â”€ App.css         ğŸ‘ˆ Estilos de App
 â”œâ”€â”€ components/     ğŸ‘ˆ Carpeta con componentes reutilizables
 â””â”€â”€ ...

index.js

Importa React y ReactDOM.

Renderiza <App /> dentro del div id="root" que estÃ¡ en public/index.html.

Ejemplo:

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

App.js

Es tu primer componente, normalmente el â€œcontenedorâ€ principal.

Desde acÃ¡ vas importando otros componentes.

Componentes (components/)

Son piezas de UI. Cada uno puede tener su .js (lÃ³gica JSX) y .css (estilos).

ğŸ“Œ Hasta acÃ¡, nada de esto lo entiende el navegador directamente porque usÃ¡s JSX (<div>Hola</div>) y mÃ³dulos ES6 (import ... from ...).

ğŸ”¹ 2. Nivel intermedio: Carpeta public/

AcÃ¡ estÃ¡ el HTML base que se sirve:

public/
 â”œâ”€â”€ index.html      ğŸ‘ˆ Archivo HTML base
 â”œâ”€â”€ favicon.ico
 â””â”€â”€ manifest.json

index.html

Tiene un <div id="root"></div>.

Cuando React arranca (desde src/index.js), inserta ahÃ­ toda tu app.

Ejemplo:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mi App React</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div> <!-- React se engancha acÃ¡ -->
  </body>
</html>

ğŸ‘‰ NotÃ¡ que acÃ¡ no hay referencia a src/index.js.
Eso se inyecta automÃ¡ticamente cuando se hace el build.

ğŸ”¹ 3. El â€œpuenteâ€: npm start y npm run build

npm start: arranca un servidor de desarrollo con Webpack o Vite.

Traduce en tiempo real tu src/ a JS entendible por el navegador.

No genera archivos, todo estÃ¡ en memoria.

npm run build: hace el bundle para producciÃ³n.

Transforma src/index.js en archivos optimizados (main.js, vendor.js...).

Copia public/index.html a la carpeta build/, pero inyecta los scripts resultantes.

Resultado en build/:
build/
 â”œâ”€â”€ index.html   ğŸ‘ˆ Copia de public/index.html pero con <script>
 â””â”€â”€ static/
      â”œâ”€â”€ js/
      â”‚   â””â”€â”€ main.abcd1234.js   ğŸ‘ˆ CÃ³digo de React compilado
      â””â”€â”€ css/
          â””â”€â”€ main.abcd1234.css

Ejemplo de cÃ³mo queda el build/index.html:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mi App React</title>
    <link href="/static/css/main.abcd1234.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script src="/static/js/main.abcd1234.js"></script> <!-- Compilado de src/index.js -->
  </body>
</html>

ğŸ‘‰ Ese main.abcd1234.js es en realidad todo tu src/index.js + App + componentes, pero traducido a JS puro.

ğŸ”¹ 4. Nivel final: Firebase Hosting

Firebase no entiende JSX ni tu src/.

Solo sirve archivos estÃ¡ticos (HTML, CSS, JS).

Entonces, lo que subÃ­s es la carpeta build/.

En firebase.json lo definÃ­s asÃ­:
{
  "hosting": {
    "public": "build"
  }
}

Cuando haces:
firebase deploy

ğŸ‘‰ Firebase publica el build/index.html, que carga el main.js, y ese main.js es tu src/index.js transformado.

ğŸ”¹ 5. Resumen de la interacciÃ³n

src/index.js â†’ Renderiza tu app.

public/index.html â†’ Base HTML con <div id="root">.

Build â†’ Combina src/ + public/ en archivos listos (build/).

Firebase â†’ Sirve el build/index.html y los JS/CSS generados.

ğŸ“Œ En otras palabras:
Tu src/index.js nunca se sube tal cual a producciÃ³n â†’ siempre pasa por el proceso de build.

------------------------------------------------------------------
ğŸš¦ Flujo de un CRUD de Productos

Usuario interactÃºa con la UI

Por ejemplo, abre la pÃ¡gina /productos â†’ ahÃ­ tenÃ©s el componente ProductosPage.jsx.

Ese componente muestra la lista de productos usando tu ProductoCard.jsx en modo lectura.

Llamada a un servicio centralizado

Cuando hay que listar, crear, editar o borrar un producto, ProductosPage no llama directamente al backend.

Usa productoService.js, que tiene todas las funciones para hablar con el backend (axios.get, axios.post, etc.).

Esto permite que, si maÃ±ana cambiÃ¡s de backend (por ejemplo, de FastAPI a Firebase), solo modificÃ¡s productoService.js y no todos tus componentes.

El backend responde

Los datos vienen en JSON (ej: { id, nombre, descripcion, precio, imagenes }).

Esos datos se transforman en props y se pasan al componente reutilizable ProductoCard.jsx, que solo se encarga de mostrar.

ReutilizaciÃ³n de componentes

ProductoCard.jsx puede usarse en:

Vista de catÃ¡logo (solo lectura).

Vista de administraciÃ³n (con botones de editar/eliminar).

Vista de detalle (mÃ¡s informaciÃ³n).

Cambia el comportamiento segÃºn las props que le pases (editable={true} o false).

Formularios separados

Para crear o editar, usÃ¡s ProductoForm.jsx, que es un formulario reutilizable.

PodÃ©s usarlo tanto para:

Crear un producto (onSubmit = crearProducto).

Editar un producto (onSubmit = actualizarProducto).

CentralizaciÃ³n de lÃ³gica repetida

Subida de imÃ¡genes â†’ imageService.js.

Llamadas a productos â†’ productoService.js.

Formato de precio o validaciones â†’ podÃ©s meterlo en un archivo utils.js.

ğŸ—‚ï¸ ReutilizaciÃ³n en distintos Ã¡mbitos

Componentes UI reutilizables

ProductoCard: mostrar info.

ProductoForm: formulario.

PodrÃ­as hacer tambiÃ©n un ImageUploader.jsx â†’ que lo uses tanto en productos como en usuarios (si tienen avatar).

Servicios reutilizables

productoService: CRUD de productos.

imageService: subir imÃ¡genes.

Si maÃ±ana agregÃ¡s usuarios, hacÃ©s usuarioService.js y mantenÃ©s la misma idea.

Hooks personalizados (nivel mÃ¡s pro)

Si querÃ©s, podÃ©s crear un hook useProductos que encapsule el estado + funciones de productos.

AsÃ­ lo importÃ¡s en cualquier pÃ¡gina sin duplicar cÃ³digo.

ğŸ”„ Circuito visual simplificado
Usuario â†’ UI (ProductosPage)
         â†’ ProductoCard (mostrar)
         â†’ ProductoForm (crear/editar)
         â†’ productoService (axios â†’ backend)
         â†’ Backend responde JSON
         â†’ UI se actualiza con nuevos datos


ğŸ‘‰ Con esta estructura ya podÃ©s:

Reutilizar tarjetas y formularios.

Cambiar solo los servicios si cambia el backend.

Separar claramente presentaciÃ³n (React) de lÃ³gica (services).


------------------------------------------------------------------




------------------------------------------------------------------



------------------------------------------------------------------

































