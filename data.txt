Frontend (React) → Firebase Hosting + Firebase Auth
                   ↓
Backend (FastAPI - Python) → Railway o Render
                             ↓
PostgreSQL (Neon.tech)
                             ↓
Imágenes (Cloudinary)

------------------------------------------------------------------
Para clonar el repositorio y que funcione en otra computadora, sigue estos pasos:

Clonar el repositorio: Abre la terminal y ejecuta:

git clone <URL_DEL_REPOSITORIO>
cd <nombre_del_repositorio>

Crear y activar un entorno virtual (recomendado):

python -m venv venv
venv\Scripts\activate

Instalar las dependencias: Si tienes un archivo requirements.txt, ejecuta:

pip install -r requirements.txt

Configurar variables de entorno:

Renombra .env.example a .env. (NO HACE FALTA ESTA PARTE)
Completa los valores necesarios (Cloudinary, DATABASE_URL, etc.).
Inicializar la base de datos: Ejecuta el script de inicialización:

python tienda/fastapi_tienda/app/scripts/init_db.py (NO HACE FALTA ESTA PARTE)

Ejecutar el servidor FastAPI:

uvicorn app.main:app --reload


Notas:

Instala Python y pip si no los tienes.
Instala uvicorn si no está: pip install uvicorn.
Instala las librerías necesarias (FastAPI, SQLAlchemy, cloudinary, etc.).

------------------------------------------------------------------
1. Configurar tu Backend (FastAPI)

python -m venv env
source env/bin/activate  # Windows: .\env\Scripts\activate
pip install fastapi uvicorn python-dotenv psycopg2-binary


nueva estructura:
fastapi_tienda/
│
├── app/
│   ├── main.py               # Punto de entrada de la app
│   ├── __init__.py
│   ├── config.py             # Configuración (Cloudinary, CORS, variables de entorno)
│   ├── crud.py             
│   ├── models.py             # Modelos Pydantic
│   ├── database.py           # Simulación o conexión a base de datos
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── productos.py      # Rutas de productos
│   │   ├── imagenes.py       # Rutas de subida de imágenes
│   └── services/
│       ├── __init__.py
│       ├── cloudinary_service.py  # Lógica de subida de imágenes
│
├── .env                      # Variables de entorno
├── requirements.txt          # Dependencias del proyecto
└── README.md


Guardar dependencias:
pip freeze > requirements.txt

------------------------------------------------------------------
 2. Subir Backend a Railway
Railway:
Crear cuenta: https://railway.app

Nuevo proyecto → “Deploy from GitHub” o “Start from scratch”

Subís el proyecto a GitHub

Railway detecta main.py y requirements.txt automáticamente

Setea variable PORT = 8000 en Railway

🚀 El backend quedará disponible en https://tuapp.up.railway.app

------------------------------------------------------------------

3. Crear base de datos en Neon
Ir a: https://neon.tech

Crear proyecto → copiar cadena de conexión PostgreSQL

En tu backend, guardar en .env:
DATABASE_URL=postgresql://usuario:password@host.db.neon.tech:5432/dbname


se crea tabla con el script init_db.py que para que funcione se debe instalar:

pip install sqlalchemy psycopg2-binary
python scripts/init_db.py

Esto:

Crea la tabla productos si no existe.

Inserta dos productos de ejemplo.



------------------------------------------------------------------

------------------------------------------------------------------
4. Configurar Cloudinary (para imágenes)
Ir a: https://cloudinary.com

Crear cuenta y copiar datos del dashboard:

CLOUD_NAME

API_KEY

API_SECRET

Guardar en .env del backend
CLOUDINARY_CLOUD_NAME=...
CLOUDINARY_API_KEY=...
CLOUDINARY_API_SECRET=...


------------------------------------------------------------------
Usás cloudinary SDK en Python:

pip install cloudinary


------------------------------------------------------------------

Frontend en React:
npx create-react-app tienda-front
cd tienda-front
npm install firebase axios react-router-dom
------------------------------------------------------------------
Configurar Firebase:
Ir a: https://console.firebase.google.com

Crear proyecto → activar Authentication → elegir “Email/Password” o “Google”

Activar Hosting → te dará un dominio mi-tienda.web.app

npm install -g firebase-tools

Agregar Firebase al React:
// src/firebase.js
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";

const firebaseConfig = {
  apiKey: "...",
  authDomain: "...",
  projectId: "...",
  appId: "...",
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);


------------------------------------------------------------------
6. Conectar frontend con backend
Usás axios desde React para llamar a https://tu-backend.up.railway.app/productos

Manejás tokens de login desde Firebase para validar en tu API si querés proteger endpoints


------------------------------------------------------------------
7. Subir el frontend a Firebase Hosting

npm install -g firebase-tools
firebase login
firebase init hosting
# Seleccionás el proyecto y como carpeta `build/`
npm run build
firebase deploy


------------------------------------------------------------------
se agrega 
  "proxy": "http://localhost:8000"

en package.json del front


------------------------------------------------------------------
comandos:

npm start -> compila de manera local solo la parte de react, no se usaria mas
firebase serve ->compila de manera local solo la parte de react pero usando firebase
npm run buil -> compila todo lo aplicado de manera local para deployarlo en prod
firebase deploy -> sube los cambios a produccion

despues de hacer cambios y mostrarlo en local hay que hacer:
npm run buil
firebase serve

despues de hacer cambios y mostrarlo en PROduccion hay que hacer:
npm run buil
firebase deploy

------------------------------------------------------------------
Explicacion del funcionamiento de los archivos para react y firebase:

🔹 1. Nivel inicial: Carpeta src/

Acá está tu código fuente, el que vos programás. Ejemplo típico:
src/
 ├── index.js        👈 Punto de entrada principal
 ├── App.js          👈 Componente raíz de tu app
 ├── App.css         👈 Estilos de App
 ├── components/     👈 Carpeta con componentes reutilizables
 └── ...

index.js

Importa React y ReactDOM.

Renderiza <App /> dentro del div id="root" que está en public/index.html.

Ejemplo:

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

App.js

Es tu primer componente, normalmente el “contenedor” principal.

Desde acá vas importando otros componentes.

Componentes (components/)

Son piezas de UI. Cada uno puede tener su .js (lógica JSX) y .css (estilos).

📌 Hasta acá, nada de esto lo entiende el navegador directamente porque usás JSX (<div>Hola</div>) y módulos ES6 (import ... from ...).

🔹 2. Nivel intermedio: Carpeta public/

Acá está el HTML base que se sirve:

public/
 ├── index.html      👈 Archivo HTML base
 ├── favicon.ico
 └── manifest.json

index.html

Tiene un <div id="root"></div>.

Cuando React arranca (desde src/index.js), inserta ahí toda tu app.

Ejemplo:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mi App React</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div> <!-- React se engancha acá -->
  </body>
</html>

👉 Notá que acá no hay referencia a src/index.js.
Eso se inyecta automáticamente cuando se hace el build.

🔹 3. El “puente”: npm start y npm run build

npm start: arranca un servidor de desarrollo con Webpack o Vite.

Traduce en tiempo real tu src/ a JS entendible por el navegador.

No genera archivos, todo está en memoria.

npm run build: hace el bundle para producción.

Transforma src/index.js en archivos optimizados (main.js, vendor.js...).

Copia public/index.html a la carpeta build/, pero inyecta los scripts resultantes.

Resultado en build/:
build/
 ├── index.html   👈 Copia de public/index.html pero con <script>
 └── static/
      ├── js/
      │   └── main.abcd1234.js   👈 Código de React compilado
      └── css/
          └── main.abcd1234.css

Ejemplo de cómo queda el build/index.html:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mi App React</title>
    <link href="/static/css/main.abcd1234.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script src="/static/js/main.abcd1234.js"></script> <!-- Compilado de src/index.js -->
  </body>
</html>

👉 Ese main.abcd1234.js es en realidad todo tu src/index.js + App + componentes, pero traducido a JS puro.

🔹 4. Nivel final: Firebase Hosting

Firebase no entiende JSX ni tu src/.

Solo sirve archivos estáticos (HTML, CSS, JS).

Entonces, lo que subís es la carpeta build/.

En firebase.json lo definís así:
{
  "hosting": {
    "public": "build"
  }
}

Cuando haces:
firebase deploy

👉 Firebase publica el build/index.html, que carga el main.js, y ese main.js es tu src/index.js transformado.

🔹 5. Resumen de la interacción

src/index.js → Renderiza tu app.

public/index.html → Base HTML con <div id="root">.

Build → Combina src/ + public/ en archivos listos (build/).

Firebase → Sirve el build/index.html y los JS/CSS generados.

📌 En otras palabras:
Tu src/index.js nunca se sube tal cual a producción → siempre pasa por el proceso de build.

------------------------------------------------------------------
🚦 Flujo de un CRUD de Productos

Usuario interactúa con la UI

Por ejemplo, abre la página /productos → ahí tenés el componente ProductosPage.jsx.

Ese componente muestra la lista de productos usando tu ProductoCard.jsx en modo lectura.

Llamada a un servicio centralizado

Cuando hay que listar, crear, editar o borrar un producto, ProductosPage no llama directamente al backend.

Usa productoService.js, que tiene todas las funciones para hablar con el backend (axios.get, axios.post, etc.).

Esto permite que, si mañana cambiás de backend (por ejemplo, de FastAPI a Firebase), solo modificás productoService.js y no todos tus componentes.

El backend responde

Los datos vienen en JSON (ej: { id, nombre, descripcion, precio, imagenes }).

Esos datos se transforman en props y se pasan al componente reutilizable ProductoCard.jsx, que solo se encarga de mostrar.

Reutilización de componentes

ProductoCard.jsx puede usarse en:

Vista de catálogo (solo lectura).

Vista de administración (con botones de editar/eliminar).

Vista de detalle (más información).

Cambia el comportamiento según las props que le pases (editable={true} o false).

Formularios separados

Para crear o editar, usás ProductoForm.jsx, que es un formulario reutilizable.

Podés usarlo tanto para:

Crear un producto (onSubmit = crearProducto).

Editar un producto (onSubmit = actualizarProducto).

Centralización de lógica repetida

Subida de imágenes → imageService.js.

Llamadas a productos → productoService.js.

Formato de precio o validaciones → podés meterlo en un archivo utils.js.

🗂️ Reutilización en distintos ámbitos

Componentes UI reutilizables

ProductoCard: mostrar info.

ProductoForm: formulario.

Podrías hacer también un ImageUploader.jsx → que lo uses tanto en productos como en usuarios (si tienen avatar).

Servicios reutilizables

productoService: CRUD de productos.

imageService: subir imágenes.

Si mañana agregás usuarios, hacés usuarioService.js y mantenés la misma idea.

Hooks personalizados (nivel más pro)

Si querés, podés crear un hook useProductos que encapsule el estado + funciones de productos.

Así lo importás en cualquier página sin duplicar código.

🔄 Circuito visual simplificado
Usuario → UI (ProductosPage)
         → ProductoCard (mostrar)
         → ProductoForm (crear/editar)
         → productoService (axios → backend)
         → Backend responde JSON
         → UI se actualiza con nuevos datos


👉 Con esta estructura ya podés:

Reutilizar tarjetas y formularios.

Cambiar solo los servicios si cambia el backend.

Separar claramente presentación (React) de lógica (services).


------------------------------------------------------------------




------------------------------------------------------------------



------------------------------------------------------------------

































